<html>
  <head>
    <title>Yu-Gi-Oh! Deck Builder</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/x-icon" href="images/logo.png" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Montserrat&display=swap");
    </style>
    <style>
      * {
        padding: 0%;
        margin: 0%;
      }
      body {
        background: #1b1329;
        font-size: 20px;
        font-weight: bold;
        font-family: "Montserrat";
        color: white;
        text-align: justify;
        text-decoration: none;
      }
      h1 {
        margin: 10px;
      }
      button {
        font-size: 18px;
        font-family: "Montserrat";
        font-weight: bold;
        margin: 2px;
        padding: 2px;
      }
      #form {
        margin: 20px;
      }
      .flexdiv {
        display: flex;
      }
      .flexdivc {
        display: flex;
        justify-content: center;
      }
      #cnvResults {
        margin: 20px;
        display: none;
      }
      #cardinfo {
        margin: 20px;
        padding: 10px;
        background-color: black;
        font-size: 15px;
        font-weight: normal;
        width: 400px;
      }
      #cardinfo img {
        width: 200px;
      }
      #cardinfo p {
        margin: 3px;
      }
      #cardinfoName {
        font-size: 18px;
      }
      #autoadd {
        width: 30px;
      }
      #divDeck {
        width: min-content;
      }
      #cnvDeck {
        margin: 10px;
        background-color: black;
      }
      #cnvExDeck {
        margin: 10px;
        background-color: black;
      }
      #imgs {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="flexdivc">
      <h1>Yu-Gi-Oh! Deck Builder</h1>
    </div>
    <form id="form">
      <label for="searchname">Search card:</label>
      <input type="text" name="searchname" id="searchname" autocomplete="off" />
      <button id="btnSearch" type="button" onclick="searchCard()"></button>
    </form>
    <div class="flexdiv">
      <div>
        <canvas id="cnvResults" onclick="selectCard(event)"></canvas>
      </div>
      <div>
        <div class="flexdivc">
          <div id="cardinfo">
            <div class="flexdivc">
              <img
                id="cardinfoImg"
                src="https://dlf2pcuso4.github.io/ygo-deck-builder/images/cards/55144522.jpg"
              />
            </div>
            <div class="flexdivc">
              <p id="cardinfoName">Pot of Greed</p>
            </div>
            <div class="flexdiv">
              <p id="cardinfoRace">What does it do?</p>
              <p id="cardinfoAttribute"></p>
              <p id="cardinfoLevel"></p>
            </div>
            <p id="cardinfoEffect"></p>
            <div class="flexdiv">
              <p id="cardinfoAtk"></p>
              <p id="cardinfoDef"></p>
            </div>
          </div>
        </div>
        <div class="flexdivc">
          <button type="button" onclick="addCard()">Add to Deck</button>
          <button type="button" onclick="clearDeck()">Clear Deck</button>
          <button id="btnSortBy" type="button" onclick="sortBy()">
            Sort: Duel Links
          </button>
        </div>
        <div class="flexdivc">
          <button id="btnCopy" type="button" onclick="copyDeck()"></button>
          <button type="button" onclick="sendDeck()">Create Deck</button>
        </div>
        <div class="flexdivc">
          <label for="autoadd">Auto-add:</label>
          <input id="autoadd" type="checkbox" name="autoadd" />
        </div>
        <div class="flexdivc">
          <h2>Deck Preview</h2>
        </div>
        <div class="flexdivc">
          <div id="divDeck">
            <canvas id="cnvDeck" onclick="selectDeckCard(event)"></canvas>
            <canvas id="cnvExDeck" onclick="selectExDeckCard(event)"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div id="imgs">
      <div id="imgsResults"></div>
      <div id="imgsDeck"></div>
    </div>
  </body>
  <script>
    var jsonDataDl,
      cardData,
      cardQuery,
      imgPerRow,
      imgCount,
      imgLoadedCount,
      cardSelected;
    var cardSize = 0.3;
    var deckArray = [];
    var deckIndex = 0;
    var deckCardSize = 0.15;
    var deckImgPerRow = 8;
    var sortDeckBy = "dl";
    const btnSearch = document.getElementById("btnSearch");
    const cnvResults = document.getElementById("cnvResults");
    const ctxResults = cnvResults.getContext("2d");
    const cardinfoImg = document.getElementById("cardinfoImg");
    const cardinfoName = document.getElementById("cardinfoName");
    const cardinfoRace = document.getElementById("cardinfoRace");
    const cardinfoAttribute = document.getElementById("cardinfoAttribute");
    const cardinfoLevel = document.getElementById("cardinfoLevel");
    const cardinfoEffect = document.getElementById("cardinfoEffect");
    const cardinfoAtk = document.getElementById("cardinfoAtk");
    const cardinfoDef = document.getElementById("cardinfoDef");
    const btnSortBy = document.getElementById("btnSortBy");
    const btnCopy = document.getElementById("btnCopy");
    const autoadd = document.getElementById("autoadd");
    const cnvDeck = document.getElementById("cnvDeck");
    const ctxDeck = cnvDeck.getContext("2d");
    const cnvExDeck = document.getElementById("cnvExDeck");
    const ctxExDeck = cnvExDeck.getContext("2d");
    const imgsResults = document.getElementById("imgsResults");
    const imgsDeck = document.getElementById("imgsDeck");
    class Card {
      constructor(id, dlpriority, mdpriority) {
        this.id = id;
        this.dlpriority = dlpriority;
        this.mdpriority = mdpriority;
      }
    }
    window.onload = async function () {
      btnSearch.innerHTML = "Pending...";
      cnvDeck.height = cnvExDeck.height = 0;
      cnvDeck.width = cnvExDeck.width =
        (421 * deckCardSize + 1) * deckImgPerRow;
      btnCopy.innerHTML = "Copy Deck Code";
      let jsonResponseDl = await fetch(
        "https://dlf2pcuso4.github.io/ygo-deck-builder/carddb-dl.json"
      );
      jsonDataDl = await jsonResponseDl.json();
      btnSearch.innerHTML = "Search";
    };
    //card searching
    function searchCard() {
      if (
        btnSearch.innerHTML == "Search" &&
        document.getElementById("searchname").value
      ) {
        btnSearch.innerHTML = "Searching...";
        imgsResults.innerHTML = "";
        imgLoadedCount = 0;
        cardQuery = document.getElementById("searchname").value;
        //fetch from api
        cardData = jsonDataDl.filter(function (a) {
          let q = a.name.toLowerCase();
          let r = a.description.toLowerCase();
          return (
            q.includes(cardQuery.toLowerCase()) ||
            r.includes(cardQuery.toLowerCase())
          );
        });
        //prepare result canvas
        if (cardData.length == 0) {
          cnvResults.style.display = "none";
          btnSearch.innerHTML = "No results found";
          setTimeout(function () {
            btnSearch.innerHTML = "Search";
          }, 1500);
        } else {
          cnvResults.style.display = "block";
        }
        cnvResults.width = 850;
        imgPerRow = Math.floor(cnvResults.width / (421 * cardSize + 10));
        cnvResults.height =
          (614 * cardSize + 10) * Math.ceil(cardData.length / imgPerRow);
        imgCount = cardData.length;
        //append images of all search results
        for (let c = 0; c < imgCount; c++) {
          let img = document.createElement("img");
          img.id = "img" + c;
          if (cardData[c].konamiID) {
            img.src =
              "https://dlf2pcuso4.github.io/ygo-deck-builder/images/cards/" +
              cardData[c].konamiID +
              ".jpg";
          } else {
            img.src =
              "https://dlf2pcuso4.github.io/ygo-deck-builder/images/cards/" +
              cardData[c].name +
              ".jpg";
          }
          imgsResults.appendChild(img);
        }
        //draw all appended images on canvas (after all images are loaded)
        for (let c = 0; c < imgCount; c++) {
          document.getElementById("img" + c).onload = function () {
            imgLoadedCount++;
            btnSearch.innerHTML =
              "Loading images (" + imgLoadedCount + "/" + imgCount + ")...";
            if (imgLoadedCount == imgCount) {
              for (let d = 0; d < imgCount; d++) {
                ctxResults.drawImage(
                  document.getElementById("img" + d),
                  (421 * cardSize + 10) * (d % imgPerRow),
                  (614 * cardSize + 10) * Math.floor(d / imgPerRow),
                  421 * cardSize,
                  614 * cardSize
                );
              }
              btnSearch.innerHTML = "Done!";
              setTimeout(function () {
                btnSearch.innerHTML = "Search";
              }, 1500);
            }
          };
        }
      }
    }
    //display card info when a search result is clicked
    function selectCard(e) {
      //click location detection
      const rect = cnvResults.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cardSelected =
        Math.floor(y / (614 * cardSize + 10)) * imgPerRow +
        Math.floor(x / (421 * cardSize + 10));
      //modify dom
      cardinfoImg.src = document.getElementById("img" + cardSelected).src;
      cardinfoName.innerHTML = cardData[cardSelected].name;
      cardinfoRace.innerHTML = "Type: " + cardData[cardSelected].race;
      if (cardData[cardSelected].attribute == null) {
        cardinfoAttribute.innerHTML = "";
      } else {
        cardinfoAttribute.innerHTML =
          "Attribute: " + cardData[cardSelected].attribute;
      }
      if (cardData[cardSelected].level == null) {
        cardinfoLevel.innerHTML = "";
      } else {
        cardinfoLevel.innerHTML = "Level/Rank: " + cardData[cardSelected].level;
      }
      cardinfoEffect.innerHTML = cardData[cardSelected].description
        .replace(/\r\n----------------------------------------\r\n/g, "<br>")
        .replace(/\n/g, "<br>");
      if (cardData[cardSelected].atk == null) {
        cardinfoAtk.innerHTML = "";
      } else {
        cardinfoAtk.innerHTML = "ATK: " + cardData[cardSelected].atk;
      }
      if (cardData[cardSelected].def == null) {
        cardinfoDef.innerHTML = "";
      } else {
        cardinfoDef.innerHTML = "DEF: " + cardData[cardSelected].def;
      }
      if (autoadd.checked == true) {
        addCard();
      }
    }
    //add card to deck
    function addCard() {
      if (cardSelected != null) {
        if (cardData[cardSelected].konamiID) {
          //add card id to array, then draw image
          let newcard = new Card(
            cardData[cardSelected].konamiID,
            dlCardPriority(
              cardData[cardSelected].konamiID,
              cardData[cardSelected].monsterType,
              cardData[cardSelected].type,
              cardData[cardSelected].rarity,
              cardData[cardSelected].level,
              cardData[cardSelected].linkRating
            ),
            mdCardPriority(
              cardData[cardSelected].konamiID,
              cardData[cardSelected].monsterType,
              cardData[cardSelected].type,
              cardData[cardSelected].level,
              cardData[cardSelected].linkRating,
              cardData[cardSelected].race
            )
          );
          if (
            deckArray.filter(function (a) {
              return a.id == newcard.id;
            }).length < 3 &&
            checkDeckSpace(newcard.dlpriority)
          ) {
            deckArray[deckIndex] = newcard;
            //append card image if it is not a duplicate
            if (
              document.getElementById(
                "deckimg" + cardData[cardSelected].konamiID
              ) == null
            ) {
              let img = document.createElement("img");
              img.id = "deckimg" + cardData[cardSelected].konamiID;
              img.src =
                "https://dlf2pcuso4.github.io/ygo-deck-builder/images/cards/" +
                cardData[cardSelected].konamiID +
                ".jpg";
              imgsDeck.appendChild(img);
            }
            refreshDeck();
            deckIndex++;
          }
        } else {
          alert(
            cardData[cardSelected].name +
              " cannot be added into the deck as it is a Duel Links exclusive card."
          );
        }
      }
    }
    //sort priority function (etrlldddddddddd)(15 char)
    //e: extra deck card type
    //t: card type (monster, spell, trap)
    //r: rarity
    //l: level/link
    //d: card id
    function dlCardPriority(id, monstertype, type, rarity, level, link) {
      let priority = 100000000000000;
      let levellink = 0;
      if (level) {
        levellink = level;
      } else if (link) {
        levellink = link;
      }
      if (monstertype.includes("Fusion")) {
        priority = 500000000000000;
      } else if (monstertype.includes("Synchro")) {
        priority = 400000000000000;
      } else if (monstertype.includes("Xyz") || monstertype.includes("XYZ")) {
        priority = 300000000000000;
      } else if (monstertype.includes("Link")) {
        priority = 200000000000000;
      }
      if (rarity == "UR") {
        priority += 4000000000000;
      } else if (rarity == "SR") {
        priority += 3000000000000;
      } else if (rarity == "R") {
        priority += 2000000000000;
      } else if (rarity == "N") {
        priority += 1000000000000;
      }
      if (type.includes("Monster")) {
        if (monstertype.includes("Ritual")) {
          priority += 50000000000000 + levellink * 10000000000;
        } else if (monstertype.includes("Normal")) {
          priority += 30000000000000 + levellink * 10000000000;
        } else {
          priority += 40000000000000 + levellink * 10000000000;
        }
      } else if (type.includes("Spell")) {
        priority += 20000000000000;
      } else if (type.includes("Trap")) {
        priority += 10000000000000;
      }
      priority += Number(id);
      return priority;
    }
    //master duel sort priority function (etrlldddddddddd)
    //e: extra deck card type
    //t: card type (monster, spell, trap)
    //r: rarity (always 0)
    //l: 99 - level/link or spell/trap type ranking
    //d: card id
    function mdCardPriority(id, monstertype, type, level, link, race) {
      let priority = 100000000000000;
      let levellink = 0;
      if (level) {
        levellink = 99 - level;
      } else if (link) {
        levellink = 99 - link;
      }
      if (monstertype.includes("Fusion")) {
        priority = 500000000000000;
      } else if (monstertype.includes("Synchro")) {
        priority = 400000000000000;
      } else if (monstertype.includes("Xyz") || monstertype.includes("XYZ")) {
        priority = 300000000000000;
      } else if (monstertype.includes("Link")) {
        priority = 200000000000000;
      }
      if (type.includes("Monster")) {
        if (monstertype.includes("Ritual")) {
          priority += 30000000000000 + levellink * 10000000000;
        } else if (monstertype.includes("Normal")) {
          priority += 50000000000000 + levellink * 10000000000;
        } else {
          priority += 40000000000000 + levellink * 10000000000;
        }
      } else if (type.includes("Spell")) {
        if (race.includes("Normal")) {
          priority += 20060000000000;
        } else if (race.includes("Equip")) {
          priority += 20050000000000;
        } else if (race.includes("Field")) {
          priority += 20040000000000;
        } else if (race.includes("Ritual")) {
          priority += 20030000000000;
        } else if (race.includes("Continuous")) {
          priority += 20020000000000;
        } else if (race.includes("Quick-Play")) {
          priority += 20010000000000;
        }
      } else if (type.includes("Trap")) {
        if (race.includes("Normal")) {
          priority += 10030000000000;
        } else if (race.includes("Counter")) {
          priority += 10020000000000;
        } else if (race.includes("Continuous")) {
          priority += 10010000000000;
        }
      }
      priority += Number(id);
      return priority;
    }
    //checks if deck has space
    function checkDeckSpace(priority) {
      if (priority > 200000000000000) {
        if (
          deckArray.filter(function (a) {
            return a.dlpriority > 200000000000000;
          }).length < 15
        ) {
          return true;
        } else {
          return false;
        }
      } else {
        if (
          deckArray.filter(function (a) {
            return a.dlpriority < 200000000000000;
          }).length < 60
        ) {
          return true;
        } else {
          return false;
        }
      }
    }
    //remove a card when a card in deck is clicked
    function selectDeckCard(e) {
      //click location detection
      const rect = cnvDeck.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const index =
        Math.floor(y / (614 * deckCardSize + 1)) * deckImgPerRow +
        Math.floor(x / (421 * deckCardSize + 1)) +
        deckArray.filter(function (a) {
          return a.dlpriority > 200000000000000;
        }).length;
      //shift all elements
      if (index < deckArray.length) {
        for (let c = index; c < deckArray.length - 1; c++) {
          deckArray[c] = deckArray[c + 1];
        }
        deckArray.length--;
        deckIndex--;
        refreshDeck();
      }
    }
    //remove a card when a card in extra deck is clicked
    function selectExDeckCard(e) {
      //click location detection
      const rect = cnvExDeck.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const index =
        Math.floor(y / (614 * deckCardSize + 1)) * deckImgPerRow +
        Math.floor(x / (421 * deckCardSize + 1));
      //shift all elements
      if (index < deckArray.length) {
        for (let c = index; c < deckArray.length - 1; c++) {
          deckArray[c] = deckArray[c + 1];
        }
        deckArray.length--;
        deckIndex--;
        refreshDeck();
      }
    }
    //sort mode toggle
    function sortBy() {
      if (sortDeckBy == "dl") {
        sortDeckBy = "md";
        btnSortBy.innerHTML = "Sort: Master Duel";
      } else {
        sortDeckBy = "dl";
        btnSortBy.innerHTML = "Sort: Duel Links";
      }
      refreshDeck();
    }
    //draw all cards in array to deck canvas
    function refreshDeck() {
      //sort deck
      if (deckIndex > 0) {
        switch (sortDeckBy) {
          case "dl":
            deckArray.sort(function (a, b) {
              return b.dlpriority - a.dlpriority;
            });
            break;
          case "md":
            deckArray.sort(function (a, b) {
              return b.mdpriority - a.mdpriority;
            });
            break;
        }
      }
      let indexmain = 0;
      cnvDeck.height =
        (614 * deckCardSize + 1) *
        Math.ceil(
          deckArray.filter(function (a) {
            return a.dlpriority < 200000000000000;
          }).length / deckImgPerRow
        );
      cnvExDeck.height =
        (614 * deckCardSize + 1) *
        Math.ceil(
          deckArray.filter(function (a) {
            return a.dlpriority > 200000000000000;
          }).length / deckImgPerRow
        );
      for (let c = 0; c < deckArray.length; c++) {
        if (deckArray[c].dlpriority > 200000000000000) {
          ctxExDeck.drawImage(
            document.getElementById("deckimg" + deckArray[c].id),
            (421 * deckCardSize + 1) * (c % deckImgPerRow),
            (614 * deckCardSize + 1) * Math.floor(c / deckImgPerRow),
            421 * deckCardSize,
            614 * deckCardSize
          );
        } else {
          ctxDeck.drawImage(
            document.getElementById("deckimg" + deckArray[c].id),
            (421 * deckCardSize + 1) * (indexmain % deckImgPerRow),
            (614 * deckCardSize + 1) * Math.floor(indexmain / deckImgPerRow),
            421 * deckCardSize,
            614 * deckCardSize
          );
          indexmain++;
        }
      }
    }
    //clear deck
    function clearDeck() {
      imgsDeck.innerHTML = "";
      deckArray = [];
      deckIndex = 0;
      cnvDeck.height = cnvExDeck.height = 0;
    }
    //copy deck code to clipboard
    function copyDeck() {
      if (btnCopy.innerHTML == "Copy Deck Code") {
        let deckcode = "";
        for (let c = 0; c < deckArray.length; c++) {
          deckcode += deckArray[c].mdpriority;
        }
        if (copy(deckcode)) {
          btnCopy.innerHTML = "Copied!";
          setTimeout(function () {
            btnCopy.innerHTML = "Copy Deck Code";
          }, 1500);
        }
      }
    }
    //send deck code to deck-display.html
    function sendDeck() {
      let deckcode = "";
      for (let c = 0; c < deckArray.length; c++) {
        deckcode += deckArray[c].mdpriority;
      }
      window.location.href = "deck-display.html?deckcode=" + deckcode;
    }
    //basic copy text function
    function copy(text) {
      let input = document.createElement("textarea");
      input.innerHTML = text;
      document.body.appendChild(input);
      input.select();
      let result = document.execCommand("copy");
      document.body.removeChild(input);
      return result;
    }
  </script>
</html>
