<html>
  <head>
    <title>HTML Deck Builder</title>
    <meta charset="utf-8" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Montserrat&display=swap");
    </style>
    <style>
      * {
        padding: 0%;
        margin: 0%;
      }
      body {
        background: #1b1329;
        font-size: 20px;
        font-weight: bold;
        font-family: "Montserrat";
        color: white;
        text-align: justify;
        text-decoration: none;
      }
      button {
        font-size: 18px;
        font-family: "Montserrat";
        font-weight: bold;
        margin: 2px;
        padding: 2px;
      }
      #form {
        margin: 20px;
      }
      .flexdiv {
        display: flex;
      }
      .flexdivc {
        display: flex;
        justify-content: center;
      }
      #cnvResults {
        margin: 20px;
        display: none;
      }
      #cardinfo {
        margin: 20px;
        padding: 10px;
        background-color: black;
        font-size: 15px;
        font-weight: normal;
        width: 400px;
      }
      #cardinfo img {
        width: 200px;
      }
      #cardinfo p {
        margin: 3px;
      }
      #cardinfoName {
        font-size: 18px;
      }
      #autoadd {
        width: 30px;
      }
      #divDeck {
        width: min-content;
      }
      #cnvDeck {
        margin: 10px;
        background-color: black;
      }
      #cnvExDeck {
        margin: 10px;
        background-color: black;
      }
      #imgs {
        display: none;
      }
    </style>
  </head>
  <body>
    <form id="form">
      <label for="searchname">Search by card name:</label>
      <input type="text" name="searchname" id="searchname" autocomplete="off" />
      <button type="button" onclick="searchCard()">Search</button>
    </form>
    <div class="flexdiv">
      <div>
        <canvas id="cnvResults" onclick="selectCard(event)"></canvas>
      </div>
      <div>
        <div class="flexdivc">
          <div id="cardinfo">
            <div class="flexdivc">
              <img
                id="cardinfoImg"
                src="https://images.ygoprodeck.com/images/cards/55144522.jpg"
              />
            </div>
            <div class="flexdivc">
              <p id="cardinfoName">Pot of Greed</p>
            </div>
            <div class="flexdiv">
              <p id="cardinfoRace">What does it do?</p>
              <p id="cardinfoAttribute"></p>
              <p id="cardinfoLevel"></p>
            </div>
            <p id="cardinfoEffect"></p>
            <div class="flexdiv">
              <p id="cardinfoAtk"></p>
              <p id="cardinfoDef"></p>
            </div>
          </div>
        </div>
        <div class="flexdivc">
          <button type="button" onclick="addCard()">Add to Deck</button>
          <button type="button" onclick="clearDeck()">Clear Deck</button>
          <button type="button" onclick="copyDeck()">Copy Deck Code</button>
        </div>
        <div class="flexdivc">
          <label for="autoadd">Auto-add:</label>
          <input id="autoadd" type="checkbox" name="autoadd" />
        </div>
        <div class="flexdivc">
          <div id="divDeck">
            <canvas id="cnvDeck" onclick="selectDeckCard(event)"></canvas>
            <canvas id="cnvExDeck" onclick="selectExDeckCard(event)"></canvas>
          </div>
        </div>
      </div>
    </div>
    <div id="imgs">
      <div id="imgsResults"></div>
      <div id="imgsDeck"></div>
    </div>
  </body>
  <script>
    var cardResponse,
      cardData,
      cardQuery,
      imgPerRow,
      imgCount,
      imgLoadedCount,
      cardSelected;
    var cardSize = 0.3;
    var deckArray = [];
    var deckIndex = 0;
    var deckCardSize = 0.15;
    var deckImgPerRow = 8;
    const cnvResults = document.getElementById("cnvResults");
    const ctxResults = cnvResults.getContext("2d");
    const cardinfoImg = document.getElementById("cardinfoImg");
    const cardinfoName = document.getElementById("cardinfoName");
    const cardinfoRace = document.getElementById("cardinfoRace");
    const cardinfoAttribute = document.getElementById("cardinfoAttribute");
    const cardinfoLevel = document.getElementById("cardinfoLevel");
    const cardinfoEffect = document.getElementById("cardinfoEffect");
    const cardinfoAtk = document.getElementById("cardinfoAtk");
    const cardinfoDef = document.getElementById("cardinfoDef");
    const autoadd = document.getElementById("autoadd");
    const cnvDeck = document.getElementById("cnvDeck");
    const ctxDeck = cnvDeck.getContext("2d");
    const cnvExDeck = document.getElementById("cnvExDeck");
    const ctxExDeck = cnvExDeck.getContext("2d");
    const imgsResults = document.getElementById("imgsResults");
    const imgsDeck = document.getElementById("imgsDeck");
    cnvDeck.height = cnvExDeck.height = 0;
    cnvDeck.width = cnvExDeck.width = (421 * deckCardSize + 1) * deckImgPerRow;
    class Card {
      constructor(id, priority) {
        this.id = id;
        this.priority = priority;
      }
    }
    //card searching
    async function searchCard() {
      imgsResults.innerHTML = "";
      imgLoadedCount = 0;
      cardQuery = document.getElementById("searchname").value;
      //fetch from api
      cardResponse = await fetch(
        "https://db.ygoprodeck.com/api/v7/cardinfo.php?fname=" + cardQuery
      );
      cardData = await cardResponse.json();
      //prepare result canvas
      if (cardData.data == null) {
        cnvResults.style.display = "none";
        alert("No results found");
      } else {
        cnvResults.style.display = "block";
      }
      cnvResults.width = 850;
      imgPerRow = Math.floor(cnvResults.width / (421 * cardSize + 10));
      cnvResults.height =
        (614 * cardSize + 10) * Math.ceil(cardData.data.length / imgPerRow);
      imgCount = cardData.data.length;
      //append images of all search results
      for (let c = 0; c < imgCount; c++) {
        let img = document.createElement("img");
        img.id = "img" + c;
        img.src =
          "https://images.ygoprodeck.com/images/cards/" +
          cardData.data[c].id +
          ".jpg";
        imgsResults.appendChild(img);
      }
      //draw all appended images on canvas (after all images are loaded)
      for (let c = 0; c < imgCount; c++) {
        document.getElementById("img" + c).onload = function () {
          imgLoadedCount++;
          if (imgLoadedCount == imgCount) {
            for (let d = 0; d < imgCount; d++) {
              ctxResults.drawImage(
                document.getElementById("img" + d),
                (421 * cardSize + 10) * (d % imgPerRow),
                (614 * cardSize + 10) * Math.floor(d / imgPerRow),
                421 * cardSize,
                614 * cardSize
              );
            }
          }
        };
      }
    }
    //display card info when a search result is clicked
    function selectCard(e) {
      //click location detection
      const rect = cnvResults.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      cardSelected =
        Math.floor(y / (614 * cardSize + 10)) * imgPerRow +
        Math.floor(x / (421 * cardSize + 10));
      //modify dom
      cardinfoImg.src = document.getElementById("img" + cardSelected).src;
      cardinfoName.innerHTML = cardData.data[cardSelected].name;
      cardinfoRace.innerHTML = "Type: " + cardData.data[cardSelected].race;
      if (cardData.data[cardSelected].attribute == null) {
        cardinfoAttribute.innerHTML = "";
      } else {
        cardinfoAttribute.innerHTML =
          "Attribute: " + cardData.data[cardSelected].attribute;
      }
      if (cardData.data[cardSelected].level == null) {
        cardinfoLevel.innerHTML = "";
      } else {
        cardinfoLevel.innerHTML =
          "Level/Rank: " + cardData.data[cardSelected].level;
      }
      cardinfoEffect.innerHTML = cardData.data[cardSelected].desc
        .replace(/\r\n----------------------------------------\r\n/g, "<br>")
        .replace(/\n/g, "<br>");
      if (cardData.data[cardSelected].atk == null) {
        cardinfoAtk.innerHTML = "";
      } else {
        cardinfoAtk.innerHTML = "ATK: " + cardData.data[cardSelected].atk;
      }
      if (cardData.data[cardSelected].def == null) {
        cardinfoDef.innerHTML = "";
      } else {
        cardinfoDef.innerHTML = "DEF: " + cardData.data[cardSelected].def;
      }
      if (autoadd.checked == true) {
        addCard();
      }
    }
    //add card to deck
    function addCard() {
      if (cardSelected != null) {
        //add card id to array, then draw image
        let newcard = new Card(
          cardData.data[cardSelected].id,
          cardPriority(
            cardData.data[cardSelected].id,
            cardData.data[cardSelected].type,
            cardData.data[cardSelected].level,
            cardData.data[cardSelected].linkval
          )
        );
        if (
          deckArray.filter(function (a) {
            return a.id == newcard.id;
          }).length < 3 &&
          checkDeckSpace(newcard.priority)
        ) {
          deckArray[deckIndex] = newcard;
          //sort deck
          if (deckIndex > 0) {
            deckArray.sort(function (a, b) {
              return b.priority - a.priority;
            });
          }
          //append card image if it is not a duplicate
          if (
            document.getElementById(
              "deckimg" + cardData.data[cardSelected].id
            ) == null
          ) {
            let img = document.createElement("img");
            img.id = "deckimg" + cardData.data[cardSelected].id;
            img.src =
              "https://images.ygoprodeck.com/images/cards/" +
              cardData.data[cardSelected].id +
              ".jpg";
            imgsDeck.appendChild(img);
          }
          refreshDeck();
          deckIndex++;
        }
      }
    }
    //sort priority function (etlldddddddddd)
    //e: extra deck card type
    //t: card type (monster, spell, trap)
    //l: 99 - level/link
    //d: card id
    function cardPriority(id, type, level, link) {
      let priority = 10000000000000;
      let levellink = 0;
      if (level) {
        levellink = 99 - level;
      } else if (link) {
        levellink = 99 - link;
      }
      if (type.includes("Fusion")) {
        priority = 50000000000000;
      } else if (type.includes("Synchro")) {
        priority = 40000000000000;
      } else if (type.includes("XYZ")) {
        priority = 30000000000000;
      } else if (type.includes("Link")) {
        priority = 20000000000000;
      }
      if (type.includes("Monster")) {
        if (type.includes("Ritual")) {
          priority += 3000000000000 + levellink * 10000000000;
        } else if (type.includes("Normal")) {
          priority += 5000000000000 + levellink * 10000000000;
        } else {
          priority += 4000000000000 + levellink * 10000000000;
        }
      } else if (type.includes("Spell")) {
        priority += 2000000000000;
      } else if (type.includes("Trap")) {
        priority += 1000000000000;
      }
      priority += id;
      return priority;
    }
    //checks if deck has space
    function checkDeckSpace(priority) {
      if (priority > 20000000000000) {
        if (
          deckArray.filter(function (a) {
            return a.priority > 20000000000000;
          }).length < 15
        ) {
          return true;
        } else {
          return false;
        }
      } else {
        if (
          deckArray.filter(function (a) {
            return a.priority < 20000000000000;
          }).length < 60
        ) {
          return true;
        } else {
          return false;
        }
      }
    }
    //remove a card when a card in deck is clicked
    function selectDeckCard(e) {
      //click location detection
      const rect = cnvDeck.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const index =
        Math.floor(y / (614 * deckCardSize + 1)) * deckImgPerRow +
        Math.floor(x / (421 * deckCardSize + 1)) +
        deckArray.filter(function (a) {
          return a.priority > 20000000000000;
        }).length;
      //shift all elements
      if (index < deckArray.length) {
        for (let c = index; c < deckArray.length - 1; c++) {
          deckArray[c] = deckArray[c + 1];
        }
        deckArray.length--;
        deckIndex--;
        refreshDeck();
      }
    }
    //remove a card when a card in extra deck is clicked
    function selectExDeckCard(e) {
      //click location detection
      const rect = cnvExDeck.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const index =
        Math.floor(y / (614 * deckCardSize + 1)) * deckImgPerRow +
        Math.floor(x / (421 * deckCardSize + 1));
      //shift all elements
      if (index < deckArray.length) {
        for (let c = index; c < deckArray.length - 1; c++) {
          deckArray[c] = deckArray[c + 1];
        }
        deckArray.length--;
        deckIndex--;
        refreshDeck();
      }
    }
    //draw all cards in array to deck canvas
    function refreshDeck() {
      let indexmain = 0;
      cnvDeck.height =
        (614 * deckCardSize + 1) *
        Math.ceil(
          deckArray.filter(function (a) {
            return a.priority < 20000000000000;
          }).length / deckImgPerRow
        );
      cnvExDeck.height =
        (614 * deckCardSize + 1) *
        Math.ceil(
          deckArray.filter(function (a) {
            return a.priority > 20000000000000;
          }).length / deckImgPerRow
        );
      for (let c = 0; c < deckArray.length; c++) {
        if (deckArray[c].priority > 20000000000000) {
          ctxExDeck.drawImage(
            document.getElementById("deckimg" + deckArray[c].id),
            (421 * deckCardSize + 1) * (c % deckImgPerRow),
            (614 * deckCardSize + 1) * Math.floor(c / deckImgPerRow),
            421 * deckCardSize,
            614 * deckCardSize
          );
        } else {
          ctxDeck.drawImage(
            document.getElementById("deckimg" + deckArray[c].id),
            (421 * deckCardSize + 1) * (indexmain % deckImgPerRow),
            (614 * deckCardSize + 1) * Math.floor(indexmain / deckImgPerRow),
            421 * deckCardSize,
            614 * deckCardSize
          );
          indexmain++;
        }
      }
    }
    //clear deck
    function clearDeck() {
      imgsDeck.innerHTML = "";
      deckArray = [];
      deckIndex = 0;
      cnvDeck.height = cnvExDeck.height = 0;
    }
    //copy deck code to clipboard
    function copyDeck() {
      let deckcode = "";
      for (let c = 0; c < deckArray.length; c++) {
        deckcode += deckArray[c].priority + "+";
      }
      if (copy(deckcode.slice(0, -1))) {
        alert("Copied to clipboard!");
      }
    }
    //basic copy text function
    function copy(text) {
      let input = document.createElement("textarea");
      input.innerHTML = text;
      document.body.appendChild(input);
      input.select();
      let result = document.execCommand("copy");
      document.body.removeChild(input);
      return result;
    }
  </script>
</html>
